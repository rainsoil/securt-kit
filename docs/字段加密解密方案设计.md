# Spring Boot 2.x + MyBatis 字段加密解密方案设计

## 1. 方案概述

本方案为基于Spring Boot 2.x和MyBatis/MyBatis Plus框架的数据库字段加密解密解决方案，支持对指定表的指定字段进行自动加密存储和查询解密。

### 1.1 核心特性
- 支持配置文件方式配置需要加密的字段
- 支持注解方式标记需要加密的字段
- 自动拦截SQL执行，在插入/更新时加密，查询时解密
- 支持多种加密算法（AES、DES等）
- 支持自定义加密密钥管理
- 兼容MyBatis和MyBatis Plus

### 1.2 技术架构
```
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   应用层        │    │   拦截器层      │    │   加密层        │
│                 │    │                 │    │                 │
│ - Controller    │───▶│ - SqlInterceptor│───▶│ - Encryptor     │
│ - Service       │    │ - TypeHandler   │    │ - Decryptor     │
│ - Mapper        │    │ - Plugin        │    │ - KeyManager    │
└─────────────────┘    └─────────────────┘    └─────────────────┘
                                │
                                ▼
                       ┌─────────────────┐
                       │   配置层        │
                       │                 │
                       │ - Properties    │
                       │ - Annotations   │
                       └─────────────────┘
```

## 2. 详细设计

### 2.1 配置方式

#### 2.1.1 配置文件方式
```yaml
# application.yml
securt-kit:
  encrypt:
    enabled: true
    algorithm: AES
    key: ${ENCRYPT_KEY:your-secret-key}
    fields:
      user:
        - phone
        - email
        - id_card
      order:
        - customer_name
        - address
      payment:
        - card_number
        - cvv
```

#### 2.1.2 注解方式
```java
@Table(name = "user")
public class User {
    private Long id;
    
    @EncryptField
    private String phone;
    
    @EncryptField(algorithm = "AES")
    private String email;
    
    @EncryptField(algorithm = "DES")
    private String idCard;
    
    // getters and setters
}
```

### 2.2 核心组件设计

#### 2.2.1 加密器接口
```java
public interface Encryptor {
    String encrypt(String plainText, String key);
    String decrypt(String cipherText, String key);
    String getAlgorithm();
}
```

#### 2.2.2 密钥管理器
```java
public interface KeyManager {
    String getKey(String tableName, String fieldName);
    void rotateKey(String tableName, String fieldName);
    boolean isKeyValid(String key);
}
```

#### 2.2.3 SQL拦截器
```java
@Component
@Intercepts({
    @Signature(type = StatementHandler.class, method = "prepare", args = {Connection.class, Integer.class})
})
public class EncryptSqlInterceptor implements Interceptor {
    // 拦截SQL执行，处理加密解密逻辑
}
```

#### 2.2.4 类型处理器
```java
public class EncryptTypeHandler extends BaseTypeHandler<String> {
    // 处理MyBatis类型转换时的加密解密
}
```

### 2.3 实现流程

#### 2.3.1 插入/更新流程
```
1. 接收业务数据
2. 通过配置或注解识别需要加密的字段
3. 调用加密器对字段值进行加密
4. 将加密后的数据传递给MyBatis执行SQL
5. 加密数据存储到数据库
```

#### 2.3.2 查询流程
```
1. 执行查询SQL
2. 从数据库获取数据（包含加密字段）
3. 通过配置或注解识别需要解密的字段
4. 调用解密器对字段值进行解密
5. 返回解密后的数据给业务层
```

## 3. 技术实现

### 3.1 依赖管理
```xml
<dependencies>
    <!-- Spring Boot Starter -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter</artifactId>
    </dependency>
    
    <!-- MyBatis -->
    <dependency>
        <groupId>org.mybatis.spring.boot</groupId>
        <artifactId>mybatis-spring-boot-starter</artifactId>
        <version>2.2.0</version>
    </dependency>
    
    <!-- 加密库 -->
    <dependency>
        <groupId>org.bouncycastle</groupId>
        <artifactId>bcprov-jdk15on</artifactId>
        <version>1.68</version>
    </dependency>
    
    <!-- 配置处理 -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-configuration-processor</artifactId>
        <optional>true</optional>
    </dependency>
</dependencies>
```

### 3.2 核心类结构

```
com.chu7.securtkit.encrypt/
├── annotation/
│   └── EncryptField.java
├── config/
│   ├── EncryptProperties.java
│   └── EncryptAutoConfiguration.java
├── core/
│   ├── Encryptor.java
│   ├── Decryptor.java
│   ├── KeyManager.java
│   └── EncryptContext.java
├── handler/
│   ├── AesEncryptor.java
│   ├── DesEncryptor.java
│   └── EncryptTypeHandler.java
├── interceptor/
│   ├── EncryptSqlInterceptor.java
│   └── EncryptResultInterceptor.java
└── util/
    ├── EncryptUtil.java
    └── SqlParseUtil.java
```

## 4. 使用示例

### 4.1 实体类定义
```java
@Table(name = "user_info")
public class UserInfo {
    private Long id;
    
    @EncryptField
    private String phone;
    
    @EncryptField(algorithm = "AES")
    private String email;
    
    @EncryptField(algorithm = "DES")
    private String idCard;
    
    private String name; // 不加密字段
    
    // getters and setters
}
```

### 4.2 Mapper接口
```java
@Mapper
public interface UserInfoMapper {
    @Insert("INSERT INTO user_info(phone, email, id_card, name) VALUES(#{phone}, #{email}, #{idCard}, #{name})")
    int insert(UserInfo userInfo);
    
    @Select("SELECT * FROM user_info WHERE id = #{id}")
    UserInfo selectById(Long id);
    
    @Update("UPDATE user_info SET phone=#{phone}, email=#{email} WHERE id=#{id}")
    int update(UserInfo userInfo);
}
```

### 4.3 业务层使用
```java
@Service
public class UserInfoService {
    @Autowired
    private UserInfoMapper userInfoMapper;
    
    public void createUser(UserInfo userInfo) {
        // phone, email, idCard字段会自动加密
        userInfoMapper.insert(userInfo);
    }
    
    public UserInfo getUserById(Long id) {
        // phone, email, idCard字段会自动解密
        return userInfoMapper.selectById(id);
    }
}
```

## 5. 安全考虑

### 5.1 密钥管理
- 密钥不应硬编码在代码中
- 支持从环境变量、配置中心获取密钥
- 支持密钥轮换机制
- 密钥存储应使用安全的密钥管理系统

### 5.2 加密算法
- 默认使用AES-256加密算法
- 支持自定义加密算法
- 加密结果使用Base64编码存储

### 5.3 性能优化
- 使用缓存减少重复的加密解密操作
- 支持批量操作优化
- 异步处理大量数据的加密解密

## 6. 配置说明

### 6.1 完整配置示例
```yaml
securt-kit:
  encrypt:
    enabled: true
    algorithm: AES
    key: ${ENCRYPT_KEY:your-secret-key-32-chars}
    key-rotation:
      enabled: false
      interval: 30d
    cache:
      enabled: true
      size: 1000
      expire: 1h
    fields:
      user_info:
        - phone
        - email
        - id_card
      order_info:
        - customer_name
        - customer_phone
        - delivery_address
      payment_info:
        - card_number
        - cvv
        - account_number
    exclude-tables:
      - system_config
      - log_info
```

### 6.2 配置项说明
- `enabled`: 是否启用加密功能
- `algorithm`: 加密算法（AES、DES等）
- `key`: 加密密钥
- `key-rotation`: 密钥轮换配置
- `cache`: 缓存配置
- `fields`: 需要加密的字段配置
- `exclude-tables`: 排除加密的表

## 7. 扩展性设计

### 7.1 自定义加密算法
```java
@Component
public class CustomEncryptor implements Encryptor {
    @Override
    public String encrypt(String plainText, String key) {
        // 自定义加密逻辑
    }
    
    @Override
    public String decrypt(String cipherText, String key) {
        // 自定义解密逻辑
    }
    
    @Override
    public String getAlgorithm() {
        return "CUSTOM";
    }
}
```

### 7.2 自定义密钥管理器
```java
@Component
public class CustomKeyManager implements KeyManager {
    @Override
    public String getKey(String tableName, String fieldName) {
        // 自定义密钥获取逻辑
    }
    
    @Override
    public void rotateKey(String tableName, String fieldName) {
        // 自定义密钥轮换逻辑
    }
    
    @Override
    public boolean isKeyValid(String key) {
        // 自定义密钥验证逻辑
    }
}
```

## 8. 测试方案

### 8.1 单元测试
- 加密解密功能测试
- 配置加载测试
- 拦截器功能测试

### 8.2 集成测试
- 完整的CRUD操作测试
- 批量操作测试
- 性能测试

### 8.3 测试用例
```java
@SpringBootTest
class EncryptTest {
    @Test
    void testEncryptDecrypt() {
        // 测试加密解密功能
    }
    
    @Test
    void testInsertAndQuery() {
        // 测试插入和查询的加密解密
    }
    
    @Test
    void testBatchOperation() {
        // 测试批量操作
    }
}
```

## 9. 部署和运维

### 9.1 部署注意事项
- 确保密钥配置正确
- 检查数据库字段类型是否支持加密数据存储
- 验证加密解密功能正常工作

### 9.2 监控和日志
- 记录加密解密操作的日志
- 监控加密解密性能指标
- 告警异常情况

### 9.3 数据迁移
- 提供数据加密迁移工具
- 支持增量数据加密
- 提供回滚方案

## 10. 总结

本方案提供了一个完整的、可扩展的数据库字段加密解密解决方案，具有以下优势：

1. **易用性**: 支持配置文件和注解两种配置方式
2. **透明性**: 对业务代码无侵入，自动处理加密解密
3. **安全性**: 支持多种加密算法和密钥管理
4. **性能**: 提供缓存和批量操作优化
5. **扩展性**: 支持自定义加密算法和密钥管理
6. **兼容性**: 兼容MyBatis和MyBatis Plus

通过本方案，可以有效保护敏感数据的安全性，同时保持系统的易用性和性能。 