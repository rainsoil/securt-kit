# 字段加密解密方案实现指南

## 1. 项目结构

首先，我们需要在 `securt-kit-core` 模块中创建加密解密功能的实现。

### 1.1 目录结构
```
securt-kit-core/
├── src/main/java/
│   └── com/chu7/securtkit/
│       └── encrypt/
│           ├── annotation/
│           │   └── EncryptField.java
│           ├── config/
│           │   ├── EncryptProperties.java
│           │   └── EncryptAutoConfiguration.java
│           ├── core/
│           │   ├── Encryptor.java
│           │   ├── KeyManager.java
│           │   └── EncryptContext.java
│           ├── handler/
│           │   ├── AesEncryptor.java
│           │   ├── DesEncryptor.java
│           │   └── EncryptTypeHandler.java
│           ├── interceptor/
│           │   ├── EncryptSqlInterceptor.java
│           │   └── EncryptResultInterceptor.java
│           └── util/
│               ├── EncryptUtil.java
│               └── SqlParseUtil.java
└── src/main/resources/
    └── META-INF/
        └── spring.factories
```

## 2. 核心实现

### 2.1 注解定义

```java
// EncryptField.java
package com.chu7.securtkit.encrypt.annotation;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Target({ElementType.FIELD})
@Retention(RetentionPolicy.RUNTIME)
public @interface EncryptField {
    /**
     * 加密算法，默认AES
     */
    String algorithm() default "AES";
    
    /**
     * 是否启用加密
     */
    boolean enabled() default true;
}
```

### 2.2 配置属性类

```java
// EncryptProperties.java
package com.chu7.securtkit.encrypt.config;

import org.springframework.boot.context.properties.ConfigurationProperties;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

@ConfigurationProperties(prefix = "securt-kit.encrypt")
public class EncryptProperties {
    
    /**
     * 是否启用加密功能
     */
    private boolean enabled = true;
    
    /**
     * 默认加密算法
     */
    private String algorithm = "AES";
    
    /**
     * 加密密钥
     */
    private String key;
    
    /**
     * 需要加密的字段配置
     */
    private Map<String, List<String>> fields = new HashMap<>();
    
    /**
     * 排除加密的表
     */
    private List<String> excludeTables = new ArrayList<>();
    
    // getters and setters...
}
```

### 2.3 加密器接口

```java
// Encryptor.java
package com.chu7.securtkit.encrypt.core;

public interface Encryptor {
    /**
     * 加密
     */
    String encrypt(String plainText, String key);
    
    /**
     * 解密
     */
    String decrypt(String cipherText, String key);
    
    /**
     * 获取算法名称
     */
    String getAlgorithm();
}
```

### 2.4 AES加密器实现

```java
// AesEncryptor.java
package com.chu7.securtkit.encrypt.handler;

import com.chu7.securtkit.encrypt.core.Encryptor;
import org.springframework.stereotype.Component;

import javax.crypto.Cipher;
import javax.crypto.spec.SecretKeySpec;
import java.util.Base64;

@Component
public class AesEncryptor implements Encryptor {
    
    private static final String ALGORITHM = "AES";
    private static final String TRANSFORMATION = "AES/ECB/PKCS5Padding";
    
    @Override
    public String encrypt(String plainText, String key) {
        try {
            SecretKeySpec secretKey = new SecretKeySpec(key.getBytes(), ALGORITHM);
            Cipher cipher = Cipher.getInstance(TRANSFORMATION);
            cipher.init(Cipher.ENCRYPT_MODE, secretKey);
            byte[] encryptedBytes = cipher.doFinal(plainText.getBytes());
            return Base64.getEncoder().encodeToString(encryptedBytes);
        } catch (Exception e) {
            throw new RuntimeException("AES加密失败", e);
        }
    }
    
    @Override
    public String decrypt(String cipherText, String key) {
        try {
            SecretKeySpec secretKey = new SecretKeySpec(key.getBytes(), ALGORITHM);
            Cipher cipher = Cipher.getInstance(TRANSFORMATION);
            cipher.init(Cipher.DECRYPT_MODE, secretKey);
            byte[] decryptedBytes = cipher.doFinal(Base64.getDecoder().decode(cipherText));
            return new String(decryptedBytes);
        } catch (Exception e) {
            throw new RuntimeException("AES解密失败", e);
        }
    }
    
    @Override
    public String getAlgorithm() {
        return ALGORITHM;
    }
}
```

### 2.5 密钥管理器

```java
// KeyManager.java
package com.chu7.securtkit.encrypt.core;

public interface KeyManager {
    /**
     * 获取密钥
     */
    String getKey(String tableName, String fieldName);
    
    /**
     * 轮换密钥
     */
    void rotateKey(String tableName, String fieldName);
    
    /**
     * 验证密钥
     */
    boolean isKeyValid(String key);
}
```

```java
// DefaultKeyManager.java
package com.chu7.securtkit.encrypt.core;

import com.chu7.securtkit.encrypt.config.EncryptProperties;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

@Component
public class DefaultKeyManager implements KeyManager {
    
    @Autowired
    private EncryptProperties properties;
    
    @Override
    public String getKey(String tableName, String fieldName) {
        return properties.getKey();
    }
    
    @Override
    public void rotateKey(String tableName, String fieldName) {
        // 实现密钥轮换逻辑
    }
    
    @Override
    public boolean isKeyValid(String key) {
        return key != null && !key.trim().isEmpty();
    }
}
```

### 2.6 SQL拦截器

```java
// EncryptSqlInterceptor.java
package com.chu7.securtkit.encrypt.interceptor;

import com.chu7.securtkit.encrypt.config.EncryptProperties;
import com.chu7.securtkit.encrypt.core.Encryptor;
import com.chu7.securtkit.encrypt.core.KeyManager;
import org.apache.ibatis.executor.statement.StatementHandler;
import org.apache.ibatis.mapping.BoundSql;
import org.apache.ibatis.plugin.*;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import java.sql.Connection;
import java.util.Properties;

@Component
@Intercepts({
    @Signature(type = StatementHandler.class, method = "prepare", args = {Connection.class, Integer.class})
})
public class EncryptSqlInterceptor implements Interceptor {
    
    @Autowired
    private EncryptProperties properties;
    
    @Autowired
    private Encryptor encryptor;
    
    @Autowired
    private KeyManager keyManager;
    
    @Override
    public Object intercept(Invocation invocation) throws Throwable {
        if (!properties.isEnabled()) {
            return invocation.proceed();
        }
        
        StatementHandler statementHandler = (StatementHandler) invocation.getTarget();
        BoundSql boundSql = statementHandler.getBoundSql();
        String sql = boundSql.getSql();
        
        // 解析SQL，识别需要加密的字段
        // 处理参数加密逻辑
        
        return invocation.proceed();
    }
    
    @Override
    public Object plugin(Object target) {
        return Plugin.wrap(target, this);
    }
    
    @Override
    public void setProperties(Properties properties) {
        // 设置属性
    }
}
```

### 2.7 结果拦截器

```java
// EncryptResultInterceptor.java
package com.chu7.securtkit.encrypt.interceptor;

import com.chu7.securtkit.encrypt.annotation.EncryptField;
import com.chu7.securtkit.encrypt.config.EncryptProperties;
import com.chu7.securtkit.encrypt.core.Encryptor;
import com.chu7.securtkit.encrypt.core.KeyManager;
import org.apache.ibatis.executor.resultset.ResultSetHandler;
import org.apache.ibatis.plugin.*;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import java.sql.Statement;
import java.util.List;
import java.util.Properties;

@Component
@Intercepts({
    @Signature(type = ResultSetHandler.class, method = "handleResultSets", args = {Statement.class})
})
public class EncryptResultInterceptor implements Interceptor {
    
    @Autowired
    private EncryptProperties properties;
    
    @Autowired
    private Encryptor encryptor;
    
    @Autowired
    private KeyManager keyManager;
    
    @Override
    public Object intercept(Invocation invocation) throws Throwable {
        if (!properties.isEnabled()) {
            return invocation.proceed();
        }
        
        Object result = invocation.proceed();
        
        // 处理查询结果，对加密字段进行解密
        if (result instanceof List) {
            processResultList((List<?>) result);
        } else if (result != null) {
            processResultObject(result);
        }
        
        return result;
    }
    
    private void processResultList(List<?> resultList) {
        for (Object obj : resultList) {
            processResultObject(obj);
        }
    }
    
    private void processResultObject(Object obj) {
        // 使用反射获取字段，检查是否有@EncryptField注解
        // 对标记的字段进行解密
    }
    
    @Override
    public Object plugin(Object target) {
        return Plugin.wrap(target, this);
    }
    
    @Override
    public void setProperties(Properties properties) {
        // 设置属性
    }
}
```

### 2.8 自动配置类

```java
// EncryptAutoConfiguration.java
package com.chu7.securtkit.encrypt.config;

import com.chu7.securtkit.encrypt.interceptor.EncryptSqlInterceptor;
import com.chu7.securtkit.encrypt.interceptor.EncryptResultInterceptor;
import org.apache.ibatis.session.SqlSessionFactory;
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
import org.springframework.boot.context.properties.EnableConfigurationProperties;
import org.springframework.context.annotation.Configuration;

import javax.annotation.PostConstruct;
import javax.annotation.Resource;
import java.util.List;

@Configuration
@EnableConfigurationProperties(EncryptProperties.class)
@ConditionalOnProperty(prefix = "securt-kit.encrypt", name = "enabled", havingValue = "true", matchIfMissing = true)
public class EncryptAutoConfiguration {
    
    @Resource
    private List<SqlSessionFactory> sqlSessionFactoryList;
    
    @Resource
    private EncryptSqlInterceptor encryptSqlInterceptor;
    
    @Resource
    private EncryptResultInterceptor encryptResultInterceptor;
    
    @PostConstruct
    public void addInterceptor() {
        for (SqlSessionFactory sqlSessionFactory : sqlSessionFactoryList) {
            sqlSessionFactory.getConfiguration().addInterceptor(encryptSqlInterceptor);
            sqlSessionFactory.getConfiguration().addInterceptor(encryptResultInterceptor);
        }
    }
}
```

## 3. 配置文件

### 3.1 spring.factories
```properties
# META-INF/spring.factories
org.springframework.boot.autoconfigure.EnableAutoConfiguration=\
com.chu7.securtkit.encrypt.config.EncryptAutoConfiguration
```

### 3.2 应用配置示例
```yaml
# application.yml
securt-kit:
  encrypt:
    enabled: true
    algorithm: AES
    key: ${ENCRYPT_KEY:your-secret-key-32-chars}
    fields:
      user_info:
        - phone
        - email
        - id_card
      order_info:
        - customer_name
        - customer_phone
    exclude-tables:
      - system_config
```

## 4. 使用示例

### 4.1 实体类
```java
@Table(name = "user_info")
public class UserInfo {
    private Long id;
    
    @EncryptField
    private String phone;
    
    @EncryptField(algorithm = "AES")
    private String email;
    
    private String name;
    
    // getters and setters
}
```

### 4.2 Mapper接口
```java
@Mapper
public interface UserInfoMapper {
    @Insert("INSERT INTO user_info(phone, email, name) VALUES(#{phone}, #{email}, #{name})")
    int insert(UserInfo userInfo);
    
    @Select("SELECT * FROM user_info WHERE id = #{id}")
    UserInfo selectById(Long id);
}
```

### 4.3 业务层
```java
@Service
public class UserInfoService {
    @Autowired
    private UserInfoMapper userInfoMapper;
    
    public void createUser(UserInfo userInfo) {
        // phone和email字段会自动加密
        userInfoMapper.insert(userInfo);
    }
    
    public UserInfo getUserById(Long id) {
        // phone和email字段会自动解密
        return userInfoMapper.selectById(id);
    }
}
```

## 5. 测试

### 5.1 单元测试
```java
@SpringBootTest
class EncryptTest {
    
    @Autowired
    private UserInfoService userInfoService;
    
    @Test
    void testEncryptDecrypt() {
        UserInfo userInfo = new UserInfo();
        userInfo.setPhone("13800138000");
        userInfo.setEmail("test@example.com");
        userInfo.setName("张三");
        
        // 插入数据
        userInfoService.createUser(userInfo);
        
        // 查询数据
        UserInfo result = userInfoService.getUserById(userInfo.getId());
        
        // 验证解密结果
        assertEquals("13800138000", result.getPhone());
        assertEquals("test@example.com", result.getEmail());
        assertEquals("张三", result.getName());
    }
}
```

## 6. 注意事项

1. **密钥管理**: 确保密钥安全存储，不要硬编码在代码中
2. **性能考虑**: 大量数据加密解密可能影响性能，建议使用缓存
3. **数据库字段**: 确保数据库字段类型支持存储加密后的数据（建议使用TEXT或VARCHAR）
4. **兼容性**: 注意与现有MyBatis配置的兼容性
5. **错误处理**: 做好异常处理和日志记录

## 7. 扩展功能

1. **多种加密算法**: 可以添加DES、RSA等其他加密算法
2. **密钥轮换**: 实现密钥自动轮换机制
3. **缓存优化**: 添加加密解密结果缓存
4. **监控告警**: 添加加密解密操作的监控和告警
5. **数据迁移**: 提供历史数据加密迁移工具
